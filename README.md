# Задание: Реализация функции обработки тегов для системы управления задачами

## Предыстория

В проекте X используется абстрактная система управления проектами (далее АСУП), которая позволяет удобно планировать выполнение задач. Каждая задача имеет следующие признаки:
- `id`: идентификационный номер задачи (int)
- `title`: заголовок задачи (str)
- `description`: описание задачи (str)
- `tags`: строка тегов, разделённых точкой с запятой (;)
- `creator`: имя и фамилия создателя задачи (str)

Проекту потребовалась возможность группировки задач по тегам для улучшения поиска, анализа и планирования. Однако до того, как было принято решение о стандартизации тегов, каждый мог создавать собственные теги, что привело к множеству дублирующих и лишних значений. Необходимо реализовать функцию, которая очистит и нормализует теги в соответствии с определёнными правилами.

## Основное задание

Требуется реализовать функцию `apply_tag_rules`, которая будет преобразовывать теги задач в соответствии с заданными правилами. Ниже приведены требования к данной функции.

### Описание работы функции

1. **Формат тега**: Все теги должны быть приведены к формату `snake_case`, если только тег не является зарезервированным (помечен флагом `immutable=True`).
2. **Таблица разрешённых тегов**: Существует таблица разрешённых тегов, которая может изменяться (удаление записей, добавление новых, изменение существующих записей) при каждом запуске программы.
3. **Проверка на наличие в разрешённых тегах**: Если преобразованный тег присутствует в поле `allowed_name` таблицы разрешённых тегов, то он остаётся в результатах.
4. **Замена синонимов**: Для некоторых тегов существуют синонимы. Синонимы должны автоматически заменяться на исходный тег из поля `allowed_name`.
5. **Незаменяемые теги**: Теги с флагом `immutable=True` нельзя изменять или преобразовывать.
6. **Удаление неизвестных тегов**: Если тег отсутствует в таблице разрешённых тегов, он должен быть удалён.
7. **Разделение составных тегов**: Если тег состоит из нескольких слов, его необходимо разделить на два, если каждое из них является разрешённым тегом (например, `DisplayService` нужно разделить на `display` и `svc`).

### Пример описания класса для хранения правил тегов
```python
from typing import NamedTuple

class AllowedTagRecord(NamedTuple):
    """Запись в таблице правил тегов."""
    allowed_name: str
    synonyms: str | None = None
    immutable: bool = False
    separated: bool = False

 def apply_tag_rules(
 tags: str, 
rules: tuple[AllowedTagRecord, ...], 
task_id: int | None = None,
 delayed_clean: bool = False
 ) -> str:
 """
 Применение правил к тегам.
 :param tags: Строка, содержащая теги.
 :param rules: Кортеж правил.
 :param task_id: идентификатор задачи, опциональное поле для дополнительного задания.
 :param delayed_clean: флаг, сигнализирующий о включении дополнительной функциональности - отложенного удаления неверных тегов.
:return str: Возвращает строку с преобразованными тегами.
 """
    # your code here
    ...
 if __name__ == "__main__":
 # пример таблицы правил
    rules = (
    # зарезервированный тег, менять нельзя
        AllowedTagRecord("SRS", immutable=True),
        AllowedTagRecord("web_engine"),
        # тег с известными синонимами
        AllowedTagRecord("sms", "сообщения, messages"),
        AllowedTagRecord("x86", "QEMU, кему"),
        # тег, при наличии в составе тега, нужно вынести в отдельный, есть
        # синоним
        AllowedTagRecord("svc", "Service", separated=True),
        AllowedTagRecord("contacts", "контакты"),
        AllowedTagRecord("display", "lcd, дисплей"),
        AllowedTagRecord("AUTO", immutable=True),
        AllowedTagRecord("lock_screen", "экран блокировки"),
    )
    for input_tags, expected_tags in (
    # тег WebEngine заменился на тег из правил web_engine
    # тег AUTO остался неизменным
        ("WebEngine; AUTO", "web_engine; AUTO"),
        # тег-синоним заменился на исходный
        ("экран блокировки; дисплэй", "lock_screen"),
        # тег-синоним заменился на исходный
        ("КеМу", "x86"),
        # тег разделился на два из-за наличия svc
        ("DisplaySvc", "display; svc"),
        # неизвестный тег, удаляем
        ("SomeTrashTag", ""),
        # нет тегов, ну и не надо
        ("", ""),
        # неизвестный тег удален, известный синоним заменен
        ("unknown-tag; lcd", "display"),
        ("auto", "AUTO"),
    ):
        assert apply_tag_rules(input_tags, rules) == expected_tags
```

## Дополнительные задания

### 1. Парсер таблицы правил из HTML-таблицы
Необходимо разработать функцию, которая будет считывать правила тегов из HTML-таблицы и преобразовывать их в формат, совместимый с функцией `apply_tag_rules`. Данная функция должна уметь обрабатывать HTML-таблицы, в которых представлены следующие данные:

- Название тега (`allowed_name`)
- Синонимы (если они существуют)
- Является ли тег неизменяемым (`immutable`)
- Признак разделяемого тега (`separated`)


### 2. Механизм отложенного удаления

 Требуется реализовать дополнительный механизм, который бы не сразу удалял неверный тег, а сохранял его в некий кеш (произвольное хранилище) сроком на 2 недели:

- **Кэширование**:
  - Кэш должен храниться локально и быть доступен на каждом запуске программы.
  - В кэше сохраняются некорректные теги с отметкой времени, когда они были добавлены.

- **Активирование механизма**:
  - Механизм отложенного удаления активируется флагом `delayed_clean`. Если этот флаг включён, то:
    - Некорректные теги добавляются в кэш и временно остаются в выходной строке до истечения срока.
    - Если срок хранения тега в кэше (2 недели) истекает, тег автоматически удаляется из выходной строки и кэша при следующем запуске программы.

- **Отключение механизма**:
  - Если флаг `delayed_clean` выключен, то:
    - Некорректные теги удаляются сразу, и кэш не используется.


## Общие требования к реализации

1. **Минимальное количество зависимостей**: 
   - Использовать только стандартные библиотеки Python, если это возможно.
   - При использовании внешних библиотек необходимо указать обоснование и название библиотеки рядом с импортом, если она решает задачу значительно эффективнее стандартных средств.

2. **Type Hints**:
   - Обязательно использовать аннотации типов (`type hints`) для всех параметров функций и возвращаемых значений, чтобы повысить читаемость и поддерживаемость кода.

3. **Документация**:
   - Весь код должен быть снабжён комментариями и документацией. Для каждой функции требуется добавить docstring, поясняющий её назначение, параметры, тип возвращаемого значения и особенности работы.
   - Docstrings должны содержать описание аргументов и возвращаемого результата с указанием типов данных.

4. **Обработка ошибок**:
   - Функции должны обрабатывать возможные исключения и ошибки, например, при работе с кэшем, чтобы программа не прерывалась из-за непредусмотренных ситуаций.
